#!/usr/bin/env node

var program = require('commander');
var fs = require('fs');
var path = require('path');
var stripJsonComments = require('strip-json-comments');
var async = require('async');

var HTMLHint  = require("../index").HTMLHint;
var pkg = require('../package.json');

require('colors');

function map(val) {
    var objMap = {};
    val.split(',').forEach(function(item){
    var arrItem = item.split(/\s*=\s*/);
    objMap[arrItem[0]] = arrItem[1]?arrItem[1]:true;
    });
    return objMap;
}

program.on('--help', function(){
    console.log('  Examples:');
    console.log('');
    console.log('    htmlhint --list');
    console.log('    htmlhint --rules tag-pair,id-class-value=underline test.html');
    console.log('    htmlhint --rulesPath ./rules test.html');
    console.log('    htmlhint --config .htmlhintrc test.html');
    console.log('');
});

program
    .version(pkg.version)
    .usage('<file ...> [options]')
    .option('-l, --list', 'show all of the rules available.')
    .option('-c, --config <file>', 'custom configuration file.')
    .option('-r, --rules <ruleid, ruleid=value ...>', 'set all of the rules available.', map)
    .option('--rulesPath <folder>', 'load custom rules from folder')
    .option('-j, --json', 'output messages as raw JSON')
    .parse(process.argv);

if(program.list){
    listRules();
    process.exit(0);
}

var arrTargets = program.args;
if(arrTargets.length === 0){
    arrTargets.push(process.cwd());
}

program.rulesPath = path.resolve(program.rulesPath);

if (!(program.rulesPath &&
    fs.existsSync(program.rulesPath) &&
    fs.lstatSync(program.rulesPath).isDirectory())) {
    console.log('Bad custom folder for rule: '.red,program.rulesPath);
    process.exit(0);
}

hintTargets(arrTargets, {
    ruleset: program.rules,
    json: program.json,
    rulesPath: program.rulesPath
});

// list all rules
function listRules(){
    var rules = HTMLHint.rules;
	var rule;
    console.log('     All rules:');
    console.log(' ==================================================');
    for (var id in rules){
        rule = rules[id];
        console.log('     %s : %s', rule.id.bold, rule.description);
    }
}

function hintTargets(arrTargets, options){
    var allFileCount = 0;
    var allHintCount = 0;

    var rulesPath = path.resolve(options.rulesPath);

    // json mode
    var json = options.json;
    var arrJson = [];
    if(!json){
        console.log('');
    }
    if (rulesPath) {
        fs.readdir(rulesPath, function(err, rules) {
            rules.forEach(function(ruleName) {
                var rulePath = path.join(rulesPath,ruleName);
                var rule = require(rulePath);

                rule(HTMLHint);
            });
        });
    }


    var arrTasks = [];
    arrTargets.forEach(function(target){
        target = path.resolve(target);
        if(fs.existsSync(target)){
            arrTasks.push(function(next){
                hintAllFiles(target, options, function(result){
                    allFileCount += result.targetFileCount;
                    allHintCount += result.targetHintCount;
                    arrJson = arrJson.concat(result.arrJson);
                    next();
                });
            });
        }
    });
    async.series(arrTasks, function(){
        if(json){
            console.log(JSON.stringify(arrJson));
        }
        else{
            if(allHintCount > 0){
                console.log('%d errors in %d files'.red, allHintCount, allFileCount);
            }
            else{
                console.log('Done, without errors.'.green);
            }
        }
        process.exit(allHintCount > 0 ? 1: 0);
    });
}

// hint all files
function hintAllFiles(target, options, onFinised){
    // hint count
    var targetFileCount = 0;
    var targetHintCount = 0;

    // json mode
    var json = options.json;
    var arrJson = [];

    // init ruleset
    var ruleset = options.ruleset;
    if(ruleset === undefined){
        ruleset = getConfig(program.config, target, json);
    }

    // hint queue
    var hintQueue = async.queue(function (filepath, next) {
        var messages = hintFile(filepath, ruleset);
        var hintCount = messages.length;
        if(hintCount > 0){
            if(json){
                arrJson.push({'file': filepath, 'messages': messages});
            }
            else{
                console.log('   '+path.relative(process.cwd(), filepath).white);
                messages.forEach(function(hint){
                    var leftWindow = 40;
                    var rightWindow = leftWindow + 20;
                    var evidence = hint.evidence;
                    var line = hint.line;
                    var col = hint.col;
                    var evidenceCount = evidence.length;
                    var leftCol = col > leftWindow + 1 ? col - leftWindow : 1;
                    var rightCol = evidence.length > col + rightWindow ? col + rightWindow : evidenceCount;
                    if(col < leftWindow + 1){
                        rightCol += leftWindow - col + 1;
                    }
                    evidence = evidence.replace(/\t/g, ' ').substring(leftCol - 1, rightCol);
                    // add ...
                    if(leftCol > 1){
                        evidence = '...' + evidence;
                        leftCol -= 3;
                    }
                    if(rightCol < evidenceCount){
                        evidence += '...';
                    }
                    // show evidence
                    console.log('      L%d |%s'.white, line, evidence.gray);
                    // show pointer & message
                    var pointCol = col - leftCol;
                    // add double byte character
                    var match = evidence.substring(0, pointCol).match(/[^\u0000-\u00ff]/g);
                    if(match !== null){
                        pointCol += match.length;
                    }
                    console.log('      %s^ %s'.white, repeatStr(String(line).length + 3 + pointCol), (hint.message + ' (' + hint.rule.id+')')[hint.type === 'error'?'red':'yellow']);
                });
                console.log('');
            }
            targetFileCount ++;
            targetHintCount += hintCount;
        }
        setImmediate(next);
    }, 10);
    // start hint
    var isWalkDone = false;
    var isHintDone = true;
    var stats = fs.statSync(target);
    if(stats.isDirectory()){
        walkPath(target, function onPath(filepath){
            isHintDone = false;
            hintQueue.push(filepath);
        }, function onFinised(){
            isWalkDone = true;
            checkAllHinted();
        });
    }
    else{
        isWalkDone = true;
        hintQueue.push(target);
    }
    hintQueue.drain = function() {
        isHintDone = true;
        checkAllHinted();
    };
    function checkAllHinted(){
        if(isWalkDone && isHintDone){
            onFinised({
                targetFileCount: targetFileCount,
                targetHintCount: targetHintCount,
                arrJson: arrJson
            });
        }
    }
}

// search and load config
function getConfig(configFile, target, json){
    if(configFile === undefined){
        // find default config file in parent directory
        if(fs.statSync(target).isDirectory() === false){
            target = path.dirname(target);
        }
        while(target){
            var tmpConfigFile = path.resolve(target+path.sep, '.htmlhintrc');
            if(fs.existsSync(tmpConfigFile)){
                configFile = tmpConfigFile;
                break;
            }
            target = target.substring(0,target.lastIndexOf(path.sep));
        }
    }

    if(fs.existsSync(configFile)){
        var config = fs.readFileSync(configFile, 'utf-8'),
            ruleset;
        try{
            ruleset = JSON.parse(stripJsonComments(config));
            if(!json){
                console.log('   Config loaded: %s', configFile.cyan);
                console.log('');
            }
        }
        catch(e){}
        return ruleset;
    }
}

// walk path
function walkPath(dir, callback, onFinish) {
    fs.readdir(dir, function (err, files) {
        var arrTasks = [];
        files.forEach(function(file){
            arrTasks.push(function(next){
                var pathname = path.join(dir, file);
                fs.stat(pathname, function (err, stats) {
                    if(stats){
                        if (stats.isDirectory()) {
                            if(/^(\.svn|\.git|\.build|node_modules)$/i.test(file) === false){
                                walkPath(pathname, callback, next);
                            }
                            else{
                                next();
                            }
                        } else {
                            if(/\.html?$/i.test(file)){
                                callback(path.normalize(pathname));
                            }
                            next();
                        }
                    }
                    else{
                        next();
                    }
                });
            });
        });
        async.series(arrTasks, function(){
            onFinish && onFinish();
        });
    });
}

// hint file
function hintFile(filepath, ruleset){
    var content = fs.readFileSync(filepath, 'utf-8');
    return HTMLHint.verify(content, ruleset);
}

// repeat string
function repeatStr(n, str){
    return new Array(n + 1).join(str || ' ');
}
